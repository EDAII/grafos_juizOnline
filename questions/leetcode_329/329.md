# A questão

É um desafio que pede para encontrar o **comprimento do caminho crescente mais longo** dentro de uma **matriz de inteiros**.  

A cada célula `(i, j)` é permitido mover-se para **cima, baixo, esquerda ou direita**, mas apenas se o valor do destino for **estritamente maior** que o atual.  
O caminho não pode sair dos limites da matriz nem se mover na diagonal.

![329 Questão](../../assets/329_longest_increasing_path_in_a_matrix/329_question.png)

---

# Estratégia

A solução interpreta a matriz como um **grafo direcionado acíclico (DAG)**:  
- Cada célula é um **nó**;  
- Há uma **aresta** de `(i, j)` → `(x, y)` se `matrix[x][y] > matrix[i][j]`.  

O objetivo é encontrar o **caminho mais longo** nesse grafo.  
Para isso, é usada uma busca em profundidade (**DFS**) com **memoização**, armazenando o comprimento máximo já calculado a partir de cada célula para evitar recomputações.

Essa técnica garante que cada célula seja processada apenas uma vez, tornando o algoritmo eficiente mesmo para matrizes grandes.

---

# Algoritmo utilizado

- **Estrutura de dados:** matriz `memo` para cache dos resultados de cada célula.  
- **Etapas principais:**
  1. Percorrer todas as células da matriz.  
  2. Para cada célula, executar uma **DFS** recursiva que busca todos os vizinhos maiores.  
  3. Armazenar em `memo[i][j]` o tamanho máximo do caminho crescente a partir daquela posição.  
  4. Retornar o maior valor encontrado entre todas as células.

---

# Resultado

A solução encontra corretamente o comprimento do maior caminho crescente, aproveitando a estrutura de grafo da matriz.  
O uso de DFS com memoização reduz a complexidade para O(m × n), tornando-a escalável e otimizada.

![329 Accepted](../../assets/329_longest_increasing_path_in_a_matrix/329_accepted.png)
